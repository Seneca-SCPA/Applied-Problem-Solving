{"searchDocs":[{"title":"Data Structures","type":0,"sectionRef":"#","url":"/Applied-Problem-Solving/data-structures","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Data Structures","url":"/Applied-Problem-Solving/data-structures#overview","content":" Data structures...  ","version":"Next","tagName":"h2"},{"title":"Declaring a Data Structure​","type":1,"pageTitle":"Data Structures","url":"/Applied-Problem-Solving/data-structures#declaring-a-data-structure","content":" How it is done for both methods:  FlowchartPseudo code  ","version":"Next","tagName":"h2"},{"title":"Declaring a Data Structure Variable​","type":1,"pageTitle":"Data Structures","url":"/Applied-Problem-Solving/data-structures#declaring-a-data-structure-variable","content":" How it is done for both methods:  FlowchartPseudo code  ","version":"Next","tagName":"h2"},{"title":"Accessing Data​","type":1,"pageTitle":"Data Structures","url":"/Applied-Problem-Solving/data-structures#accessing-data","content":" Specific member/attribute  How it is done for both methods:  FlowchartPseudo code  ","version":"Next","tagName":"h2"},{"title":"Declaring a collection of Data Structures (array)​","type":1,"pageTitle":"Data Structures","url":"/Applied-Problem-Solving/data-structures#declaring-a-collection-of-data-structures-array","content":" How it is done for both methods:  FlowchartPseudo code  ","version":"Next","tagName":"h2"},{"title":"Accessing Data of an Array of Data Structures​","type":1,"pageTitle":"Data Structures","url":"/Applied-Problem-Solving/data-structures#accessing-data-of-an-array-of-data-structures","content":" Specific itemAll items (iteration)  How it is done for both methods:  FlowchartPseudo code ","version":"Next","tagName":"h2"},{"title":"Documenting Logic","type":0,"sectionRef":"#","url":"/Applied-Problem-Solving/documenting-logic","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Documenting Logic","url":"/Applied-Problem-Solving/documenting-logic#overview","content":" The previous section on computational thinking focused on the computational thinking model and how it applies to the problem solving process. Now, lets focus on how we will document and communicate logic.  There are many possible ways to document and communicate algorithms, however these notes will be focused on two very popular methods:  FlowchartPseudo Code  NOTE For the purposes of these notes, we'll be using flowcharts to communicate a simplified view of an algorithm and pseudo code for communicating the details of an algorithm.  It was stated in the introduction to these notes, we will not be concerned with any specific programming language syntax (language agnostic) and will be focused primarily on the logic.  In staying with this theme and to establish consistency and clear program-language agnostic communication of algorithms, a minimal set of guidelines will need to be applied for each of these methods.  ","version":"Next","tagName":"h2"},{"title":"Flowchart​","type":1,"pageTitle":"Documenting Logic","url":"/Applied-Problem-Solving/documenting-logic#flowchart","content":" Flowcharts are highly visual as they are constructed with graphical symbols to represent information and process flows (algorithms) in a more simplified view.  Flowcharts are much more challenging to construct for complex detailed algorithms given the intensive application of graphical components - it can sometimes take more time to arrange the graphical symbols than it did to create the entire algorithm!  Flowcharts are used primarily for two purposes:  To illustrate technical algorithms to non-technical persons. Flowcharts are a great way to communicate algorithms and technical information to non-technical persons who are not programmers or those who only need to have an overview of the algorithm and not the lower-level details. For technical persons to view detailed algorithms from a different perspective Technical persons like programmers will often use flowcharting to view a smaller more specific part of an algorithm to better understand it from a different perspective and to better &quot;visualize&quot; it. This often sparks more creative ways to address logic.Note: Flowcharts with detailed algorithms is outside the scope of these notes and will not be covered.  Given these notes will be focused on purpose #1, this will limit a solution to having only one flowchart providing a simplified outline of the main algorithm needed to solve a problem. The flowchart will be an abstraction of the overall solution providing enough information to non-technical persons of the intent and major logic flows of the solution.  ","version":"Next","tagName":"h2"},{"title":"Graphical Symbols​","type":1,"pageTitle":"Documenting Logic","url":"/Applied-Problem-Solving/documenting-logic#graphical-symbols","content":" Flowcharts are actually standardized by the International Organization for Standardization ISO and depending on the sector/field of discipline and type of information you are using flowcharts for, will have its own set of standardized symbols that should be used. Overall there is an extensive library of symbols representing very specific meaning and should be used when appropriate.  To stay within the scope of these notes, a very limited set of the most common symbols will be used:  Symbol-Image\tSymbol-Shape\tDescription\tSquashed Oval\tStart of the algorithm (with function name) Squashed Oval\tEnd of the algorithm Rectangle\tSimple process or action Striped Rectangle\tComplex function (a pseudo code function or a closed-box process) Diamond\tDecision (change in logical flow) Text Label\tText to describe decision output flow (placed on top of the line) Lines with Arrows\tFlow direction used to join symbols (indicates the next symbol to execute)  ","version":"Next","tagName":"h3"},{"title":"Simple Example​","type":1,"pageTitle":"Documenting Logic","url":"/Applied-Problem-Solving/documenting-logic#simple-example","content":" Throughout the notes as programming logic is introduced, detailed examples applying the guidelines will be provided. In the meantime, here's a simple example to give you some idea of what flowcharting is about.    ","version":"Next","tagName":"h3"},{"title":"Pseudo Code​","type":1,"pageTitle":"Documenting Logic","url":"/Applied-Problem-Solving/documenting-logic#pseudo-code","content":" Pseudo code is a programmer's go-to choice for documenting algorithms. This is because of how flexible it is to modify and reorganize logic which is a very common activity when creating algorithms. Unlike flowcharts which is graphical, pseudo code is textual and describes logic with concise clear human-language (English in this case). It is also easy to copy/paste the content directly into your code file to work from.  &quot;Pseudo&quot; meaning not genuine or false, indicates this type of describing logic is not genuine code (staying true to our rule of not programming in any specific language). Pseudo code can be more technical than flowcharts, but does not use any programming language specific syntax, but instead, describes the logical intent at the level programmers can use to program the logic to any programming language desired.  Pseudo code can be constructed in many different ways and generally we all have our own stylistic way of doing it but as mentioned in the overview, there will be some guidelines applied for the sake of consistency and clear communication. The guidelines described in these notes are minimal but effective general rules that are a good base to work from while you eventually establish your own style.  ","version":"Next","tagName":"h2"},{"title":"General Guidelines​","type":1,"pageTitle":"Documenting Logic","url":"/Applied-Problem-Solving/documenting-logic#general-guidelines","content":" Guideline\tDescriptionEnumeration\tEach step or instruction should have a corresponding sequence number or letter. When nested logic is applied, enumeration resets using the opposite number or letter sequence. Indentation\tThe term nesting will be explained later, but it is crucial to consistently indent (or TAB) each level of logic that is nested. Alignment\tOverall horizontal left-alignment is critical to keeping statements organized and easily identifiable as to which each statement is related to or apart of other parts of logic (especially when nesting). Flow-through Logic\tLogic should flow naturally to the next step. You should not have instructions that state &quot;continue to the next step&quot; as this is the natural sequence when one statement ends, it automatically assumes to continue to the next statement in sequence. Jump Statements\tLogic flow needs to be carefully managed and NEVER apply &quot;jump statements&quot; which direct logic to jump ahead skipping many steps. Example: if step #5 instructs &quot;GO TO step #99&quot; this is extremely poor design and not acceptable!  ","version":"Next","tagName":"h3"},{"title":"Simple Example​","type":1,"pageTitle":"Documenting Logic","url":"/Applied-Problem-Solving/documenting-logic#simple-example-1","content":" As mentioned in the flowchart section, throughout the notes as programming logic is introduced, detailed examples applying the guidelines will be provided. In the meantime, here's a simple example to give you some idea of what pseudo coding is about.  This example has two functions defined that were referenced from the preceding flowchart example above.  GetAnimalCount(animalType) 1. DECLARE: count = 0 2. DISPLAY: &quot;Tap the [ADD 1] button to add 1 to the counter or [DONE] when you are finished counting &lt;animalType&gt; Count:&lt;count&gt; BUTTON: [ADD 1] BUTTON: [DONE]&quot; 3. Which button was tapped? A. ADD : 1. Add 1 to count 2. Repeat from step:2 B. DONE : 1. DISPLAY: &quot;Are you sure? BUTTON: [YES] BUTTON: [NO]&quot; 2. Which button was tapped? A. NO: 1. Repeat from step:2 C. NONE : 1. Repeat from step:2 4. Return count 5. END   EstimatedYardSize(totalAnimals, spacePerAnimal) 1. DECLARE: feedTrough = 3 waterTrough = 6 estAnimalSpace = &lt;totalAnimals&gt; * &lt;spacePerAnimal&gt; 2. DISPLAY: &quot;Do you need a feeding trough? BUTTON: [YES] BUTTON: [NO]&quot; 3. Which button was tapped? A. NO: 1. ASSIGN: feedTrough = 0 4. DISPLAY: &quot;Do you need a water trough? BUTTON: [YES] BUTTON: [NO]&quot; 5. Which button was tapped? A. NO: 1. ASSIGN: waterTrough = 0 6. DISPLAY: &quot;Total Animals : &lt;totalAnimals&gt; Est. Animal Space: &lt;estAnimalSpace&gt; m2 Feed Trough : &lt;feedTrough&gt; water Trough : &lt;waterTrough&gt; ---------------------------------------- Total Estimate : &lt;estAnimalSpace&gt; + &lt;feedTrough&gt; + &lt;waterTrough&gt;&quot; 7. END  ","version":"Next","tagName":"h3"},{"title":"Computational Thinking","type":0,"sectionRef":"#","url":"/Applied-Problem-Solving/computational-thinking","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Computational Thinking","url":"/Applied-Problem-Solving/computational-thinking#overview","content":" Computational thinking is a flexible model programmers use to formulate a computer-based solution. One of the objectives of the computational thinking model is to get you thinking like a programmer, but also to aid in organizing your approach to problem solving. There are variations of this model, but commonly there are seven identifiable core parts:  Understand the ProblemDecompositionData RepresentationPattern RecognitionAbstractionAlgorithmTesting  The sequence of this list is based on the most common application of these parts, but by no means is it strict or concrete – depending on the problem, you may omit parts all together or swap some parts around as needed.  Problem solving is often iterative (repeating) and when changes are made in one major part it can have a cascading (snowball) effect on other parts. It is common to have to review other parts or at least anything related to parts that have changed, and this can be difficult to manage so you need to have a process that helps you do this which is where the computational thinking model comes in.  Ultimately what you want to accomplish is the creation of a complete correctly working algorithm that solves the problem which can be used by a programmer to quickly and efficiently code the solution.  Let’s have a closer look at each of these core parts.  ","version":"Next","tagName":"h2"},{"title":"Understand the Problem​","type":1,"pageTitle":"Computational Thinking","url":"/Applied-Problem-Solving/computational-thinking#understand-the-problem","content":"   This may seem obvious, but understanding the problem is critical given the major side effects of what happens when the actual problem is misunderstood. If the problem is not fully understood, the outcome will almost certainly not be a solution to the problem resulting in many angry people (ranging from your peers, stakeholders, and even your family!).  Developing computer solutions is a time demanding and costly process so be sure to have a complete understanding of the problem to avoid wasting time and money on efforts not applicable to the problem you need to solve.  The most common failure is making assumptions. The problem is not always clear and depending on who is responsible for defining the problem (the client versus a project manager for instance), the details can be misleading or completely missing critical information. Assumptions are easy to make in cases where meaning is ambiguous or not explicit so be sure to confirm your assumptions before proceeding.    Here is an example of a poorly worded problem that can lead to all sorts of possible &quot;solutions&quot; because it is too vague and ambiguous:  &quot;The yearly revenue report doesn't work and needs to be corrected before we move on to the next phase of the project.&quot;  The issue is in the term &quot;doesn't work&quot;. This phrase can so easily be misinterpreted - what exactly doesn't work?  Are the calculations incorrect?Is the data corrupt?Could it be a minor cosmetic or formatting problem that only one person doesn't like?Is the application interface components not arranged in the way this one person likes?  If you make the assumption of any one of these things, you will most likely be incorrect. In these situations, you MUST seek clarity and precisely determine what &quot;doesn't work&quot; actually means. Without an explicitly defined problem, you can't deliver a solution!  caution The viewpoint of a &quot;problem&quot; is often very subjective - what one person may see as an issue, another person may not agree. These issues are usually worked out by a project manager but for smaller projects, it is unlikely to have this benefit, so keep your guard up and always make sure there is general consensus supporting a common request.  Having a clear understanding of the problem will provide you with the scope and boundaries of both the problem and the solution you need to create. This is extremely important as it will keep you focused on only the pertinent details of the problem and avoid wasting time, money, and effort into unrelated matters.  ","version":"Next","tagName":"h2"},{"title":"Decomposition​","type":1,"pageTitle":"Computational Thinking","url":"/Applied-Problem-Solving/computational-thinking#decomposition","content":"   Most problems are too complex or are too dynamic in nature to immediately start creating a solution. Decomposing a problem into many smaller scoped problems greatly simplify many aspects of creating a solution. This step is mainly focused on identifying the major pieces of logic that can be extracted from the problem.  Isolating a specific part of a problem, removes irrelevant parts and greatly reduces the overall complexity for that part. This allows us to easily concentrate only on the important aspects of the smaller problem. Generally, there is no such thing as a complex problem – we just need to break it down into easier to solve smaller parts!    Here is an example of decomposition based on part of a much larger problem :  &quot;The website should provide our administrators the ability to view the clerks who are currently logged-in to the system and for any selected clerk, provide options to send a message, disconnect them from the system, or assign a new task.&quot;  There are several significant pieces of the problem we can extract from this:  The website user-interface (displaying the logged-in clerks and providing action options when a specific clerk is selected). Possible function name: &quot;InitializeClerksLoggedIn&quot;This function's scope will be limited to focusing only on preparing the interface, getting and displaying the logged-in user data listing, and providing the options for a selection. Sending a message to a specific clerk Possible function name: &quot;SendClerkMessage&quot;This function's scope will be limited to focusing only on how an administrator can send a message to a selected clerk from the list. Disconnecting a specific clerk Possible function name: &quot;DisconnectClerk&quot;This function's scope will be limited to focusing only on how a selected logged-in user is disconnected. Assigning a new task to a specific clerk Possible function name: &quot;AssignClerkTask&quot;This function's scope will be limited to focusing only on how a selected logged-in user is assigned a new task.  These are four major pieces of the problem that can be extracted and focused on to solve individually. These can be compartmentalized into specific functions where the logic can be isolated to solve only that specific part of the problem.    The process of identifying smaller parts of the problem can validate your understanding of the problem and confirms the overall scope. Often this process will identify missed or undefined parts of the problem that will need to be clarified which could likely expand the scope or sometimes have the opposite effect where irrelevant parts are identified and could likely reduce the scope.  Reducing a large problem into many smaller parts, promotes a lot of flexibility in how you will orchestrate and reassemble these smaller solutions together when finalizing a complete solution. It is important to take your time in this phase to filter for only the critical information and processes.  NOTE This stage often identifies the potential core functions (procedures) to be created and used in the solution.Functions represent algorithms comprised of several logical steps which perform a specific task (this will be described in more detail later on)  ","version":"Next","tagName":"h2"},{"title":"Data Representation​","type":1,"pageTitle":"Computational Thinking","url":"/Applied-Problem-Solving/computational-thinking#data-representation","content":"   Information (data) is a major part of a computer-based solution since the data can significantly impact how the solution works and what it must do with the data. How data is received, used, or output is not the focus in this step, rather the objective is to identify WHAT the relevant data is and to ensure it is represented in a way it can be used in the solution.  Data representation is accomplished by representing data with variables (the technical aspect of this is covered later). Variables are named placeholders which can be referred to within the solution to access specific information by name to refer to the value. For example, if we needed to manage data about a person’s contact information, some key data would be:  Information\tVariable\tValueFull Name\tname\tJiminy Cricket Email Address\temail\tjcricket@domain.com Cell Number\tcell\t(123) 123-1234  The important information in this example is a person’s name, email address, and cell phone number. These important pieces of data are mapped or represented by variables which can be named to anything you wish but should almost always apply a self-documented identifier to clearly represent the data while not being too long.  When we refer to the variable name, it will represent a value corresponding to that variable which in this example is Jiminy Cricket. Likewise, if we needed to refer to the email address data jcricket@domain.com, then the variable email would be used to target this information.  One question you may raise during this phase is about how much data you need to manage/represent and how granular (broken down into parts) you need to make it. In the preceding example, there is a name variable which includes the full name – does the solution require you to make a distinction between first and last name parts? If so, then you will need to represent this data separately where the name variable would need to be split into two variables such as firstName and lastName (or surname). Eliminating the original variable name. When you need to refer to the full name, you would simply join these two variables accordingly.  There is an additional more advanced concept we can use to help manage more complex data representation, but this will be discussed later in two other sections:  data collectionsdata structures  ","version":"Next","tagName":"h2"},{"title":"Pattern Recognition​","type":1,"pageTitle":"Computational Thinking","url":"/Applied-Problem-Solving/computational-thinking#pattern-recognition","content":"   After decomposing a problem into several smaller parts (let’s say for example we have identified three functions as illustrated in the above image) and in outlining each of those functions, you notice repetition in the logic. The repetition can be within the same function and/or in other functions – this is undesirable! Why? Let’s analyze the example further.  NOTE The breakdown of these functions as described below is an overview only. You will learn how to properly document logic later.  Function: AddContact This will detail all the steps needed to add the details of a new contactAfter the user enters an email address, the email field will be validated to ensure the email entered matches the expected format (value@value.value). The email validation logic will require several steps of logic to implement: Makes sure there are no invalid charactersMakes sure there is a single @ symbol and not the first characterMakes sure there is a . symbol and at least 2 characters after the @ and not the last characterMakes sure the overall length is not excessive (ie. &gt; 256 characters)    Function: UpdateContact This will detail all the steps needed to update the details of an existing contactAfter the user enters an email address, the email field will be validated to ensure the email entered matches the expected format (value@value.value). The email validation logic will require several steps of logic to implement: Makes sure there are no invalid charactersMakes sure there is a single @ symbol and not the first characterMakes sure there is a . symbol and at least 2 characters after the @ and not the last characterMakes sure the overall length is not excessive (ie. &gt; 256 characters)    Function: SearchContact (based on email field) This will detail all the steps needed to search for a specific contact based on a user-entered email address and then display the contact detailsAfter the user enters an email address, the email field will be validated to ensure the email entered matches the expected format (value@value.value). The email validation logic will require several steps of logic to implement: Makes sure there are no invalid charactersMakes sure there is a single @ symbol and not the first characterMakes sure there is a . symbol and at least 2 characters after the @ and not the last characterMakes sure the overall length is not excessive (ie. &gt; 256 characters)    All three functions contain the same email validation logic which means this would be coded (by a programmer) three separate times! Why is this undesirable?  What if the email validation logic has a bug (an error that doesn’t properly validate the email)? You would have to review and change potentially all three functions that repeat this logic. It is very inefficient to maintain this type of design and is error-prone given the redundancy (could have three versions of validation all of which could be slightly different). Another case is if the email formatting rules change, again, this would require updating all occurrences of this logic. What is the solution to this?  You should extract the repeating logic into its own function where the logic can be defined once, then in other parts of the solution where you need that logic implemented, you execute that logic when and where you need it. The function you create should be given a meaningful name that best describes what it does so it’s easy to use and communicate. In this example the function could be called ValidateEmail. Now, the three other functions can be updated to CALL the new function ValidateEmail eliminating the redundancy of fully detailing how that logic works in three different places!    *NEW* Function: ValidateEmail Validates the email address to ensure the email entered matches the expected format (value@value.value) snf will be the ONLY place where this logic is defined.Makes sure there are no invalid charactersMakes sure there is a single @ symbol and not the first characterMakes sure there is a . symbol and at least 2 characters after the @ and not the last characterMakes sure the overall length is not excessive (ie. &gt; 256 characters)Now this logic can easily be used by other parts of the solution whenever needed without repetition.    Function: AddContact This will detail all the steps needed to add the details of a new contactAfter the user enters an email address, CALL ValidateEmail    Function: UpdateContact This will detail all the steps needed to update the details of an existing contactAfter the user enters an email address, CALL ValidateEmail    Function: SearchContact (based on email field) This will detail all the steps needed to search for a specific contact based on a user-entered email address and then display the contact detailsAfter the user enters an email address, CALL ValidateEmail    Several lines of logic are now removed from each of the functions (AddContact, UpdateContact, and SearchContact) because there is now a common function called ValidateEmail and each function that needs this logic implementation simply CALL's that function (ex: CALL ValidateEmail) when needed.  The below image illustrates the correction to the illustration at the beginning of this section.    There is another situation where you may reveal a repeating pattern but does not necessarily require a function to address it. Sometimes the repetition is purely semantic (logical) and can be handled using iteration which is a concept covered later.  SUMMARY Patterns exhibiting a duplication in logic can usually be addressed by making a dedicated function which contains the logic in a single place. The function can then be called from anywhere in the solution to implement that logic whenever needed. Functions provide many benefits: Single place to manage the logicSimplifies the reading of logic (don't need to know how the logic works everywhere it is used)Reduces the overall footprint size of the solution by eliminating redundant detailed logic There are also situations where logic duplication is purely semantic (logical) and can be managed using a logic control method referred to as iteration.  ","version":"Next","tagName":"h2"},{"title":"Abstraction​","type":1,"pageTitle":"Computational Thinking","url":"/Applied-Problem-Solving/computational-thinking#abstraction","content":"   Abstraction is an extension of pattern recognition in that you can observe similar logic across many parts of the solution but are different in only minor ways, however the main essence of the logic is the same. Logic where the overall concept or idea can be reused but execute slightly differently across different contexts is an abstraction. Let's look at an example of this.  An application is needed to produce a business report for management that shows weekly data about their sales. The report data contains the date (formatted as: YYYY-MM-DD and is the Sunday of each week), salesperson name, and the total sales for that salesperson for that week - all reports use the same data but there are six main ways to view the report: By the date -&gt; ascending orderBy the date -&gt; descending orderBy the salesperson's total sales -&gt; ascending orderBy the salesperson's total sales -&gt; descending orderBy the salesperson's name -&gt; ascending orderBy the salesperson's name -&gt; descending order  NOTE Since all the report views use the same report data, we will represent the dataset with a variable reportData.  You might initially break this down so there is a function for each possible report view (notice the report data is sent to the function so the function can access the data):  SortByDateDescending (RECEIVES: reportData)SortByDateAscending (RECEIVES: reportData)SortBySalesDescending (RECEIVES: reportData)SortBySalesAscending (RECEIVES: reportData)SortBySalesPersonAscending (RECEIVES: reportData)SortBySalesPersonDescending (RECEIVES: reportData)  If we want to view the report by date in ascending order, then we would have to call the appropriate function:  CALL SortByDateAscending(reportData)  Each report view would have it's own specific function. This works fine, but you could further refine this by applying abstraction to reduce these 6 functions down to 3 functions. How? Each main report has two variants: sorting by ascending or descending order. We can take the concept of sorting by ascending or descending and merge this logic into one function for each main report view.  SortByDate (RECEIVES: reportData)SortBySales (RECEIVES: reportData)SortBySalesPerson (RECEIVES: reportData)  But wait - how can we use these functions to get the desired sorting order? Simple! We would send an additional variable or value to the respective function that would instruct the function the desired sort order. Let's update the functions now to include the extra information:  SortByDate (RECEIVES: reportData, sortOrder)SortBySales (RECEIVES: reportData, sortOrder)SortBySalesPerson (RECEIVES: reportData, sortOrder)  Now, when we call a report function we can send both the reportData AND include another piece of information that specifies the desired sortOrder. The function will use the sortOrder variable to determine the desired sorting order. Let's try it again now with this new abstracted function for the SortByDate:  CALL SortByDate(reportData, &quot;ASCENDING&quot;)  When we call the function providing the &quot;ASCENDING&quot; value, it is assigned to the variable sortOrder which the function will use to evaluate what order to sort the report.  Are we done yet? Could this be abstracted even further? YES! The primary concept being implemented in these functions is to sort data by a specific field (attribute) of data. We can apply the same idea as we did for the sortOrder and add another piece of information to send the function which would specify the field or attribute of the data to sort on! If we added this extra piece of information, we can now reduce these three functions down to ONE! Here's what it would look like:  SortReport (RECEIVES: reportData, field, sortOrder)  With this function, it can be called in many different ways but no matter what, it will sort the data based on the field we want and in the ascending or descending order using the conditions we send to the function that are captured in the variables: field and sortOrder. If we want the report to be sorted by salesperson in descending order, we can call the function like this:  CALL SortReport(reportData, &quot;salesperson&quot;, &quot;DESCENDING&quot;)  Summary Abstraction is the process of simplifying something back to a general concept or idea.  caution Sometimes abstraction can be over-applied (just because you can abstract something doesn't necessarily mean you should). There are varying scales at which you should apply it and is always evaluated on a case-by-case basis. If the abstraction creates too much additional complexity then you should reevaluate and find another approach. In the above example, where the second level of abstraction was applied where we reduced three functions down to one function, might have taken it too far as that function is now a lot more complex. Perhaps leaving it at the first level of abstraction having three functions would be more suitable and manageable to maintain (but is certainly better than the original six functions!).  ","version":"Next","tagName":"h2"},{"title":"Algorithm​","type":1,"pageTitle":"Computational Thinking","url":"/Applied-Problem-Solving/computational-thinking#algorithm","content":"   An algorithm is ultimately what we are trying to accomplish. An algorithm is a complete set of instructions in the sequence they must occur to solve a problem. Algorithms describe in detail how the logic works step-by-step. This is what would be provided to a programmer to code a solution.  The scope of an algorithm can be small or vast depending on the problem it is addressing. When we decompose larger problems into smaller ones, each smaller one (ex: function) has its own algorithm, but when we design the 'main' function that orchestrates the overall solution, it will tie together other algorithms (functions) as required to provide a full set of instructions for the entire solution.  Since algorithms detail a solution, they must be tested to ensure it in-fact provides a working solution to the entire problem and stays within the scope of the problem (see next sub-section on Testing).  To manage and communicate algorithms, programmers primarily use pseudo code as it is more efficient to work with and can provide more detail. However, flowcharts are used to provide a higher level view of the solution and is generally less detailed due to the complexity of the layout using graphical symbols. These forms of communicating logic will be covered in the next major section (Documenting Logic).  ","version":"Next","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Computational Thinking","url":"/Applied-Problem-Solving/computational-thinking#testing","content":" Testing should be done repeatedly throughout all parts of the computational thinking model. The scale at which you test will depend on what it is you need to test. Making changes to established logic for instance would be one such time to do a concentrated and focused test to ensure the changes didn't break anything or cause other unforeseen side-effects.  The more targeted and frequent your testing is, the better your solution will be. However in reality, we usually do not have enough time to do extensive detailed testing, so we must be efficient about how and what we test (something you get better at in time).  What we minimally should test are all the known major logic flows that must occur to solve the problem and as the application would be used by users the majority of the time. We accomplish this by creating &quot;use-cases&quot;. These are the expected and common scenario's that would occur in the execution of the solution. Prioritizing the features and critical logic parts of the solution that are used the most by users will validate and ensure the solution is mostly bug-free and confirms it actually solves the problem.  Testing is where we often reveal weaknesses in the logic and where applications mostly fail, is in the unexpected things! After the core logic of the solution is tested, you would move on to more robust testing and include out of the norm conditions. One way to target this is the ask &quot;what if..&quot; and run that scenario through your solution to see if it works as expected. Be warned, once you start looking for exceptions and asking &quot;what if&quot;, this can take you well beyond what is &quot;reasonable&quot; to test so know when to stop and when you have reached the &quot;obscure&quot; that goes well-beyond normal exceptions.  ","version":"Next","tagName":"h2"},{"title":"Summary​","type":1,"pageTitle":"Computational Thinking","url":"/Applied-Problem-Solving/computational-thinking#summary","content":" In summary, programmers should plan a solution applying the computational thinking model BEFORE starting any coding. Planning ahead and having a framework to work from accelerates your coding time and results in substantially fewer errors since the difficult part of determining the logic and flow of the solution is already done. As a programmer, the coding part should only involve the syntax and implementation of the logic based on a prepared plan.  The extent to which you apply the computational model will vary depending on the problem. All parts of the model are important and will lead to great improvements in your skills to build solutions, however a couple of the parts are mandatory and you should definitely get in the habit of doing the following ALWAYS:  Understand the problemDecomposition  The other parts may take time and repetition in applying the concepts before you get comfortable and more skilled at using them. Abstraction is probably the most challenging of them because often it can be over-applied (just because you can abstract something doesn't necessarily mean you should, and there are varying scales at which you can apply it).  The act of coding a solution into a program should actually be the least time consuming part of a project. If you find otherwise, it likely means you aren't working from a planned solution, or the prepared logical plan is poorly done and needs more work.  It is always worth the time to fix the plan than it is to waste significant time debugging and rearranging your code after it's been coded! ","version":"Next","tagName":"h2"},{"title":"Data Containers & Collections","type":0,"sectionRef":"#","url":"/Applied-Problem-Solving/data-collections","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Data Containers & Collections","url":"/Applied-Problem-Solving/data-collections#overview","content":" The simplest form of a data container is an array. The concept of an array is a variable capable of storing many values. All programming languages support this simplest form of a container, but many object-oriented languages such as C++, C#, Java, Python, etc., have additional variations mostly referred to as collections which provide an additional layer of operations (functions) to help simplify the navigation and management of the data. For the sake of these notes, and to maintain the language-agnostic theme, we will merge the concepts of these two major types of data representation as one and refer to it as a collection for simplification and consistency.  ","version":"Next","tagName":"h2"},{"title":"Example Scenario​","type":1,"pageTitle":"Data Containers & Collections","url":"/Applied-Problem-Solving/data-collections#example-scenario","content":" It is very common for an application to manage information/data that supports many values which may or may not have a known limit to the number of pieces of data to maintain. For example, if an application is required to manage student ID's, we would need the application to be able to adapt to the number of student ID data (which could also involve the adding and removing of students as part of the features of the application).  We certainly would not want to represent each student ID number as a separate variable (such as: id1, id2, id3, etc..) since we would not know how many variables to declare in advance and how would we be able to add more at runtime?  Ideally, we need a way to simplify how we can represent data as a list. An important feature for this type of data representation would also include the ability to adapt to changes in the number of list items (expanding or contracting in size). This is where the concept of a collection comes in!  ONE VARIABLE! Instead of declaring MANY variables for each student ID (and given the impossibility of how we could even manage varying number of students), we can use a SINGLE collection variable to represent many student ID's (as a list)! We can declare a single collection variable: studentIDs and by referring to this one variable, we can access many student ID's.  Let's define the process for an application to manage the creation and adding of student ID's to a collection variable (where the user can enter as many ID's as desired) with the functionality to display the data stored in the collection after the data is input. We will use a flowchart to orchestrate the main flow and pseudo code to describe the detailed parts accordingly.  ","version":"Next","tagName":"h2"},{"title":"Flowchart​","type":1,"pageTitle":"Data Containers & Collections","url":"/Applied-Problem-Solving/data-collections#flowchart","content":" This is the main function and logic flow.    ","version":"Next","tagName":"h2"},{"title":"Pseudo Code​","type":1,"pageTitle":"Data Containers & Collections","url":"/Applied-Problem-Solving/data-collections#pseudo-code","content":" There are three functions to be detailed in this example.    Function: AddAnotherStudent()  ---------------------------------------------------------------- Description/Purpose: Prompt the user to confirm if another student ID needs to be entered. Argument(s) : **NONE** Return Value: TRUE for &quot;YES&quot; FALSE for &quot;NO&quot; ---------------------------------------------------------------- AddAnotherStudent() 1. DECLARE: response = FALSE 2. DISPLAY: &quot;Do you want to add a student ID?&quot; [BUTTON: YES] [BUTTON: NO] 3. What button was pressed? A) YES: 1) ASSIGN: response = TRUE B) NO: 1) ASSIGN: response = FALSE 4. RETURN: response 5. End     Function: AddStudent (studentIDs)  ---------------------------------------------------------------- Description/Purpose: Prompt the user to enter the new student ID and add it to the collection. Argument(s) : studentIDs (collection variable) Return Value: Nothing ---------------------------------------------------------------- AddStudent (studentIDs) 1. DECLARE: newStudentID 2. DISPLAY: &quot;Enter a new student ID:&quot; 3. ASSIGN: newStudentID = [User entered value] 4. ADD newStudentID to studentIDs 5. DISPLAY: &quot;Student ID added!&quot; 6. End     Function: DisplayStudentData (studentIDs)  ---------------------------------------------------------------- Description/Purpose: Display each student ID in the studentIDs collection (iterate/loop). Argument(s) : studentIDs (collection variable) Return Value: Nothing ---------------------------------------------------------------- DisplayStudentData (studentIDs) 1. DECLARE: tmpID itemCount = 0 2. DISPLAY: &quot;Here are the stored student ID's:&quot; 3. ASSIGN: tmpID = next item from studentIDs 4. Is tmpID empty? A) NO: 1. DISPLAY: &quot;[tmpID]&quot; (newline) 2. ASSIGN: itemCount + 1 3. Repeat from step #3 5. DISPLAY: &quot;There are [itemCount] Student ID's stored.&quot; 6. End  ","version":"Next","tagName":"h2"},{"title":"Modularity with Functions","type":0,"sectionRef":"#","url":"/Applied-Problem-Solving/functions","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Modularity with Functions","url":"/Applied-Problem-Solving/functions#overview","content":" Modularity is an important aspect of programming as it provides flexibility in orchestrating logic needed for efficient reusability and efficient management of solution components. The most common component of modularity is the use of functions.  Functions represent algorithms comprised of several logical steps which perform a specific task. Functions are defined once and in one place. This is what makes it efficient and simpler to manage since modifications and trouble shooting bugs directs you to a single source.  When it's time to construct a complete solution, it is nice to be able to reference functions which do all the work (hiding the details) and simplifies the overall readability of the instructions so long as good naming practices have been applied.  Sometimes access to the composition of a function may not be possible. When you don't have access to the details of a function we refer to this as a closed-box.  Reminder As mentioned in the Computational Thinking sections on: Decomposition: Functions are mostly identified when going through the process of breaking things down into smaller logical parts. Pattern Recognition: Is another area where functions may be identified where you can extract a common piece of logic that can be reused in multiple places throughout the solution. Abstraction: Usually based on a pattern of functions where the concept is the same and can be combined to simplify the usability of a single function.  ","version":"Next","tagName":"h2"},{"title":"Function Identifiers (name)​","type":1,"pageTitle":"Modularity with Functions","url":"/Applied-Problem-Solving/functions#function-identifiers-name","content":" Similarly, as variable identifiers should be well thought out and purposefully named to best describe the information it will be representing, so should the function naming process. Variables are related to DATA, but functions are related to ACTION. Therefore, function identifiers should be well thought out and purposefully named to best describe their logical purpose and action. Providing meaningful names to functions will contribute towards easier to read and manage logic (or code).  Reading logic that is applying functions should be like reading a standard sentence or close to it. There should be no mystery of WHAT the function's purpose is based on it's name however, like in variable naming practices, we need to be mindful of efficiency as we don't want to be referring to excessively long names (and in the case of programming code, we don't want to be typing them either!). That being said, unlike variable naming, function names can be a little longer given the importance of having the name best represent WHAT it does so we don't want to over abbreviate.  For example, if we need a function to write program data to a file in JSON format we could create a function with the following signature:  Function: WriteDataJSON (data)Parameter: data is what will be written to file in JSON formatReturns: TRUE (success) or FALSE (fail)  Here's an excerpt of how it would be called:  1. DECLARE: data result 2. -&gt; 99. [ logic capturing a lot of information stored to 'data' ] 100. ASSIGN: result = WriteDataJSON (data) 101. Was the data successfully exported to a file? A. result=TRUE: 1. DISPLAY: &quot;Data exported to JSON file!&quot; B. result=FALSE: 1. DISPLAY: &quot;FAILED to write to file.&quot; 102. End   Now let's consider a poorly named function that writes data to a JSON formatted file. If we replaced the name with FormatDataJSON (data). While not totally incorrect, it does not reveal the fact that data is written to a file which the term &quot;Write&quot; successfully conveys. Another poor name would be StoreData (data) - this does not reveal the formatting standard used to save the data and the term Store can also refer to variables not files.  DON'T DO THIS Do NOT obfuscate function names as this renders them meaningless to the logic if you can't easily understand a functions purpose based on the name alone: a (data)HorseGoat (data)abcdef (data) These functions are not usable since we don't know what their purpose is based on their names!  ","version":"Next","tagName":"h2"},{"title":"Function Documentation​","type":1,"pageTitle":"Modularity with Functions","url":"/Applied-Problem-Solving/functions#function-documentation","content":" Functions should be BRIEFLY described to elaborate more on WHAT the purpose of the function is to expand on the name itself (the names alone are usually not enough). This would include parameter(s) (expected arguments) and return value.  This is a very important aspect of programming especially when you get into collaborative coding and sharing of custom libraries like API's (Application Programming Interface). Functions need to be summarized so the use of the function is clear and other programmers will know how to properly apply the function.  NOTE For the purposes of these notes, pseudo code functions will be documented with a series of dashes: ------ before and after the description. See the below sub-section on Returning Information for some examples. Going forward, all examples will demonstrate function level documentation accordingly. Flowchart functions will almost always be the main function and generally will not require any documentation unless it is specific to an example requiring further detail.  Here is the template:  ---------------------------------------------------------------- Description/Purpose: [Provide a brief description of the function's purpose] Argument(s) : [List each parameter/expected argument and if needed, a brief associated description] Example: [param-1: describe briefly what this is for] [param-2: describe briefly what this is for] Return Value: [Describe possible return values if applicable] ---------------------------------------------------------------- [FunctionName] ( [Parameter(s)] ) 1. [list of steps...]   ","version":"Next","tagName":"h2"},{"title":"Closed-Boxes​","type":1,"pageTitle":"Modularity with Functions","url":"/Applied-Problem-Solving/functions#closed-boxes","content":" There will be times when we need to use 3rd-party logic (known as API's : Application Programming Interface) or other prepared logic from system library functions where we don't have access to the details of how they work.  These functions are known as &quot;closed-boxes&quot; (formerly &quot;black boxes&quot;). Closed-box functions are like &quot;magic&quot; because you call them and they do what you expect without explicitly knowing how it performed the task. It is important to note, sometimes this can be a problem because if there is a bug (error) or a missing piece of functionality in that piece of logic, there is nothing you can do to address it other than to redefine your own version of that logic in your own composed function.  How-To If you are calling a closed-box function from a flowchart, use the striped rectangle symbol to represent a complex function.  ","version":"Next","tagName":"h2"},{"title":"High-Level Functions​","type":1,"pageTitle":"Modularity with Functions","url":"/Applied-Problem-Solving/functions#high-level-functions","content":" High-level functions are usually highly abstracted in that they can represent a lot of functionality/logic usually because this type of function will call many other functions to complete its task. This is like seeing the solution from &quot;a birds eye view&quot;.  One such function that is commonly required in many programming languages is &quot;main&quot; which behaves as the entry-point to the application (or where the logic begins and typically ends).  note For the purposes of these notes, we'll be designating a flowchart to always represent this higher-level view of the overall solution. The directive of a flowchart is to describe an overall set of instructions in a simple to understand format for non-technical persons, so it is a natural and suitable application of a flowchart.  ","version":"Next","tagName":"h2"},{"title":"Low-Level Functions​","type":1,"pageTitle":"Modularity with Functions","url":"/Applied-Problem-Solving/functions#low-level-functions","content":" Unlike high-level functions, lower-level functions are a lot more focused and detailed on a task that is highly limited in scope - most functions fit this category and are constructed to be reusable or to remove complexity from other larger scoped functions.  note For the purposes of these notes, we'll be designating pseudo code to always represent these lower-level detailed parts of the solution algorithm.  ","version":"Next","tagName":"h2"},{"title":"Passing Information​","type":1,"pageTitle":"Modularity with Functions","url":"/Applied-Problem-Solving/functions#passing-information","content":" Functions usually require information to be provided or sent to it to do its task. When a function requires information, it is constructed with one or more parameters. Parameter is a fancy term used that essentially means a variable.  For example, if we create a function that is responsible for displaying the date and time in a standard ISO 8601 format (YYYY-MM-DD HH:MM:SS), the function would require all six of those specific parts of data to be supplied:  DisplayDateTime (year, month, day, hour, minute, second)   The comma delimited list of the date and time parts are the parameters. The parameters act as variables which can be used in the function logic to access the values sent to the function.  When it comes time to use this function, we will CALL it and supply the function with the information it requires (we call this &quot;passing&quot; data to a function) in the form of arguments. An argument is a value sent to a function.  Since the DisplayDateTime function has six parameters, we will need to send six arguments in the order it is expecting it:  CALL: DisplayDateTime (2025, 10, 25, 11, 53, 45)     Each argument sent to the function will be assigned to the corresponding parameter variable and then the function would construct the output assembling the variables into their appropriate sequence:  year-month-day hour:minute:second   The expected outcome of this function call, would be to display the date time data as:  2025-10-25 11:53:45   ","version":"Next","tagName":"h2"},{"title":"Returning Information​","type":1,"pageTitle":"Modularity with Functions","url":"/Applied-Problem-Solving/functions#returning-information","content":" Functions often do more than just an explicit task - it is quite common for information to be returned to the caller of the function (ex: back to where the function was called from). Most programming languages support flexible methods in how information can be returned from a function:  ExplicitImplicitBoth explicit and implicit  Let's have a look at these methods and how they will be documented in pseudo code.  Reminder Since these notes will be limiting the use of flowcharts to the main overview process only, we won't need to concern ourselves with documenting return values for flowcharting.  ","version":"Next","tagName":"h2"},{"title":"Explicit Return​","type":1,"pageTitle":"Modularity with Functions","url":"/Applied-Problem-Solving/functions#explicit-return","content":" Returning information from a function explicitly is accomplished by using the keyword: return. This method provides a single variable of information to be returned from the function.  For example, if we have a function: Multiply (number, multiple) which will return the results of multplying the provided number by the provided multiple, the logic would look like the following:  Function: Multiply (number, multiple)  ---------------------------------------------------------------- Description/Purpose: Demonstration of a function that returns a value implicitly. Argument(s) : number (operand 1 to be multiplied) multiple (operand 2 to be multiplied) Return Value: result of the multiplication ---------------------------------------------------------------- Multiply (number, multiple) 1. DECLARE: result 2. ASSIGN: result = number * multiple 3. RETURN result 4. End   This can be refined by not creating a variable:  Multiply (number, multiple) 1. RETURN number * multiple 2. End   Here is how the function can be used from a flowchart:    Here is how the function can be used from pseudo code.  Function: main()  ---------------------------------------------------------------- Description/Purpose: Demonstration of calling a function &quot;Multiply&quot; that returns a value explicitly. Argument(s) : NONE Return Value: NONE ---------------------------------------------------------------- main() 1. DECLARE: coffeePrice = 2.99 total 2. ASSIGN: total = CALL: Multiply(coffeePrice, 5) 3. DISPLAY: &quot;The cost of 5 coffee's is: $&lt;total&gt;&quot; 4. End   ","version":"Next","tagName":"h3"},{"title":"Implicit Return​","type":1,"pageTitle":"Modularity with Functions","url":"/Applied-Problem-Solving/functions#implicit-return","content":" Returning information implicitly involves updating a parameter variable. The understanding with this method is that any changes made to a parameter variable will directly affect the original. This can simplify how return values are documented but also can lead to missed data changes since it is not as clear.  Let's do another version of the preceding example using this method (notice the extra parameter total).  Function: Multiply (number, multiple, total)  ---------------------------------------------------------------- Description/Purpose: Demonstration of a function that returns a value implicitly. Argument(s) : number (operand 1 to be multiplied) multiple (operand 2 to be multiplied) total (result of multiplication) Return Value: NONE ---------------------------------------------------------------- Function: Multiply (number, multiple, total) 1. ASSIGN: total = number * multiple 2. End   The total parameter variable was used as the return value from the function by assigning the result of the calculation to that variable.  Here is how the function can be used from a flowchart:    Here is how the function can be used from pseudo code.  Function: main()  ---------------------------------------------------------------- Description/Purpose: Demonstration of calling a function &quot;Multiply&quot; that returns a value implicitly. Argument(s) : NONE Return Value: NONE ---------------------------------------------------------------- main() 1. DECLARE: coffeePrice = 2.99 total 2. CALL: Multiply(coffeePrice, 5, total) 3. DISPLAY: &quot;The cost of 5 coffee's is: $&lt;total&gt;&quot; 4. End   The advantage of implicit returns is it is not limited to a single variable return value like the explicit method. The implicit method, can return multiple values through more than one parameter variable!  Note Some programming languages refer to implicit return values through parameters as: output parameterspointersreferences  ","version":"Next","tagName":"h3"},{"title":"Both Explicit AND Implicit Returns​","type":1,"pageTitle":"Modularity with Functions","url":"/Applied-Problem-Solving/functions#both-explicit-and-implicit-returns","content":" A combination of explicit and implicit methods can be done too! Expanding on the preceding examples, we will add a tax component. The calculated tax amount will be returned implicitly via the tax parameter and the total (including tax) will be returned explicitly:  Function: Multiply (number, multiple, tax)  ---------------------------------------------------------------- Description/Purpose: Demonstration of a function that returns values applying both the implicit and explicit methods. Argument(s) : number (operand 1 to be multiplied) multiple (operand 2 to be multiplied) tax (result of tax portion) Return Value: total including tax ---------------------------------------------------------------- Multiply (number, multiple, tax) 1. DECLARE: result taxPercent = 0.13 2. ASSIGN: tax = number * multiple 3. ASSIGN: result = number * multiple + tax 4. RETURN &lt;result&gt; 5. End   Here is how the function can be used from a flowchart:    Here is how the function can be used from pseudo code:  Function: main()  ---------------------------------------------------------------- Description/Purpose: Demonstration of calling a function &quot;Multiply&quot; that returns values applying both implicit and explicit methods. Argument(s) : NONE Return Value: NONE ---------------------------------------------------------------- main() 1. DECLARE: coffeePrice = 2.99 tax total 2. ASSIGN: total = CALL: Multiply(coffeePrice, 5, tax) 3. DISPLAY: &quot;The cost of a coffee is: $&lt;coffeePrice&gt; The tax for 5 coffee's is: $&lt;tax&gt; The total for 5 coffee's is: %&lt;total&gt;&quot; 4. End   WARNING As you can see in this example, it can be easy to &quot;miss&quot; how the tax is assigned because it is IMPLICITLY updated by the function. ","version":"Next","tagName":"h3"},{"title":"Glossary of Key Terms","type":0,"sectionRef":"#","url":"/Applied-Problem-Solving/glossary","content":"Glossary of Key Terms Collection Collections are composites of other objects that include data and have logical functionality to support the containers operations. Construct A logical control such as a selection or iteration. Container Containers are very data specific in the simplest forms such as an array and do not inherently have a lot of logical functionality. Enumeration Sequencing steps with an identifier such as a number (ex: 1. 2. 3. ...) or letter (ex: A. B. C. ...). Used primarily in pseudo code to identify the execution sequence of statements. Indentation A fixed number of blank spaces to the right (ex: using the TAB key) used for aligning grouped logic that is nested. Iteration A construct that enables looping in a program - the ability to repeat a statement(s) easily. Jump Statements A poor logic flow that directs the next step of execution be an arbitrary location outside of the immediate vicinity of the current statement (ex: go to step #152). Instead, logic should be controlled using logical constructs such as selection and iteration. Modularity A term used for breaking down logic into various degrees of detail. This can be at a directory-level, file-level, function-level, or statement-level. Nest Content (statement(s), selection, or iteration) residing within a preceding construct such as a selection or iteration. The nested content would be dependant on a preceding construct and in the case of pseudo code would be indented under it. Obfuscate To purposely confuse and misdirect meaning usually by way of applying meaningless names to variables and functions. Selection A construct that enables decisions in a program to adapt to changing conditions and execute different logic flows. Semantic Is another word for logic. It is the logical definition and meaning of an algorithm. Statement A single line of instruction (step) such as a calculation, action to display or receive user input. Variable A named placeholder used to reference a value. These are used for storing data for later use and evaluation.","keywords":"","version":"Next"},{"title":"Variables","type":0,"sectionRef":"#","url":"/Applied-Problem-Solving/variables","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Variables","url":"/Applied-Problem-Solving/variables#overview","content":" As introduced in the Computational Thinking: Data Representation section, variables are named placeholders which can be referred to within the solution to access specific information by name to refer to a value.  Variables are critical in providing our solutions the ability to not just store, but use information to help determine logical pathways (selection which is covered later). Information can be simple and straight forward, but it can also be very complex. The more complex data representation will be covered much later in these notes, but in this section we'll concentrate on simple data representation and how variables are used in both flowchart and pseudo code methods of documentation.  Many programming languages are &quot;typed&quot; in that you must indicate the type of information the variable must represent (example: whole number, fractional number, characters etc.), but not all languages require this extra level of detail. Sticking with the &quot;language agnostic&quot; theme, we will not be including type information when we declare and use variables.  ","version":"Next","tagName":"h2"},{"title":"Terminology​","type":1,"pageTitle":"Variables","url":"/Applied-Problem-Solving/variables#terminology","content":" Term\tMeaningIDENTIFIER\tThe name of the variable. DECLARE\tTo create a variable which will include the IDENTIFIER. ASSIGN\tTo store a value to a variable. INITIALIZE\tTo both DECLARE and ASSIGN a value to a variable in one step.  ","version":"Next","tagName":"h2"},{"title":"Variable Identifiers (name)​","type":1,"pageTitle":"Variables","url":"/Applied-Problem-Solving/variables#variable-identifiers-name","content":" Variable identifiers should be well thought out and purposefully named to best describe the information it will be representing. It is important to apply this to your actual programming as well! Providing meaningful names to your variables will contribute towards easier to read and manage logic (or code). However, we need to be mindful of efficiency as we don't want to be referring to very long names (and in the case of programming code, we don't want to be typing them either!), so we try to use a style of shorthand to shorten the names enough without losing the context.  For instance, if we need to represent information about a customer's primary phone number and an alternate phone number, we wouldn't want to be too descriptive:  DECLARE: customerPrimaryPhoneNumber customerAlternatePhoneNumber   We would instead shorten the words to abbreviations but not to the point where we still can't understand what they are:  Pseudo Code  1. DECLARE: custPriPhone custAltPhone 2. End   Flowchart    As you immerse yourself in this industry, you will continue to learn many typical shorthand naming conventions for various information. You will get better in time and practice!  Something you may have noticed is the use of upper and lower case characters to help discern between words. This is a common naming practice (&quot;lower camel case&quot; - wikipedia) in programming which we will be applying in these notes as well.  ","version":"Next","tagName":"h2"},{"title":"Organization​","type":1,"pageTitle":"Variables","url":"/Applied-Problem-Solving/variables#organization","content":" Sometimes we need to manage a lot of information which can lead to the use of many variables. It is a standard practice to group logically related variables together and as needed, using a combination of lines and line-spacing. Grouping variables help readers find variables quickly and this helps confirm you have variables for all the data you will need representation for.  Scenario: A solution needs to represent address information for a customer and a distributor. How would you breakdown this information into appropriate variables?  Pseudo Code  1. DECLARE: custStreetNum, custStreetName, custAptUnit, custCity, custPostalZip, custCountry distStreetNum, distStreetName, distAptUnit, distCity, distPostalZip, distCountry 2. End   Flowchart    These variables are grouped by customer then by distributor and separating these two independent groups with a line break. Organizing the variables like this makes it super easy to find and confirm the data representation for each key piece of information.  DON'T DO THIS What you don't want to do is declare every variable on a single line in random order! This is very confusing and benefits nobody: Pseudo Code 1. DECLARE: distPostalZip, custStreetNum, distCity, distAptUnit, custStreetName, distStreetNum, custAptUnit, custCity, custPostalZip, distStreetName, custCountry, distCountry 2. End Flowchart ","version":"Next","tagName":"h2"},{"title":"Logic - Selection","type":0,"sectionRef":"#","url":"/Applied-Problem-Solving/selection","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Logic - Selection","url":"/Applied-Problem-Solving/selection#overview","content":" Computers programs are not very useful without the ability to adjust to changing conditions. A mechanism is therefore needed to enable programs the ability to evaluate when to change logical direction which can include executing specific logic and/or to avoid specific logic.  The concept of Selection is what provides programs the ability to apply logical decisions which can alter the execution sequence. There are several variations of selection (especially when coding it in a specific computer language), however the main three logical flows will be examined here.  ","version":"Next","tagName":"h2"},{"title":"Optional Selection​","type":1,"pageTitle":"Logic - Selection","url":"/Applied-Problem-Solving/selection#optional-selection","content":"   Optional selection provides a program the ability to execute additional logic to do something only if one or more conditions are determined TRUE, otherwise, the main program logic continues as normal.  Let's review part of a program where the total yearly rainfall is being evaluated to see if it has set a new record. The program should update the highest record only when the yearly rainfall amount is determined to be more than the last known record. The logic to update the record should only occur if the yearly rainfall has been determined to be greater than the last known record. If the yearly rainfall is 325 mm and the last known record is 310 mm, we should expect the logic to update the record to the new value, otherwise, do nothing (continue with the normal program logic).  ","version":"Next","tagName":"h2"},{"title":"Flowchart​","type":1,"pageTitle":"Logic - Selection","url":"/Applied-Problem-Solving/selection#flowchart","content":" Here is how it would be done in a flowchart:    NOTE Notice the DIAMOND shape for the selection decision.The question is using concise non-technical language.The technical part (optional) has less emphasis and is in smaller font.Something &quot;extra&quot; only occurs if it is evaluated to TRUE (yes).  ","version":"Next","tagName":"h3"},{"title":"Pseudo Code​","type":1,"pageTitle":"Logic - Selection","url":"/Applied-Problem-Solving/selection#pseudo-code","content":" Here is the pseudo code equivalent.  Function: main()  ---------------------------------------------------------------- Description/Purpose: Demonstration of optional selection. Argument(s) : NONE Return Value: NONE ---------------------------------------------------------------- main() 1. DECLARE yearlyMM = 325 recordMM = 310 2. DISPLAY: &quot;Current yearly rainfall: &lt;yearlyMM&gt; mm Highest recorded rainfall: &lt;recordMM&gt; mm&quot; 3. Is yearlyMM &gt; recordMM ? A. YES: 1. ASSIGN: recordMM = yearlyMM 2. DISPLAY: &quot;A new yearly record has been set!&quot; 4. ... Continue with program logic ... 5. End   The program will only (optionally) update the record and display a message indicating a new record was set if the current year's rainfall is higher than the previous set record. The expression in step #3 is &quot;selection&quot; where a TRUE or FALSE condition is being evaluated and based on that determination, extra logic may be executed.  NOTE Notice the text 'label' YES: used to identify the answer to the selection question?Notice the logic indentation (TAB) consistency of the pseudo code?Notice how the enumeration changed from numbers (1...2...) to characters (a...b...) when the 'inner logic' is sequenced? It is important to maintain easy to read logic in pseudo code especially when nested statements are involved. The nested statements in this example is where the group of statements are placed under the YES: logic path.  ","version":"Next","tagName":"h3"},{"title":"Alternative Selection​","type":1,"pageTitle":"Logic - Selection","url":"/Applied-Problem-Solving/selection#alternative-selection","content":"   Alternative selection is like a 'Y' in the road where a decision must be made and no matter what only one of two different logic paths will be executed but not both.  Continuing with the preceding example, the application will now display an outcome no matter what. EITHER a new rainfall record was set, OR a new record was NOT set.  ","version":"Next","tagName":"h2"},{"title":"Flowchart​","type":1,"pageTitle":"Logic - Selection","url":"/Applied-Problem-Solving/selection#flowchart-1","content":" Here is how it would be done in a flowchart:    ","version":"Next","tagName":"h3"},{"title":"Pseudo Code​","type":1,"pageTitle":"Logic - Selection","url":"/Applied-Problem-Solving/selection#pseudo-code-1","content":" And here is how it would be done in pseudo code.  Function: main()  ---------------------------------------------------------------- Description/Purpose: Demonstration of alternative selection. Argument(s) : NONE Return Value: NONE ---------------------------------------------------------------- main() 1. DECLARE yearlyMM = 325 recordMM = 310 2. DISPLAY: &quot;Current yearly rainfall: &lt;yearlyMM&gt; mm Highest recorded rainfall: &lt;recordMM&gt; mm&quot; 3. Is yearlyMM &gt; recordMM ? A. YES: 1. ASSIGN: recordMM = yearlyMM 2. DISPLAY: &quot;A new yearly record has been set!&quot; B. NO : 1. DISPLAY: &quot;Did NOT set a new record!&quot; 4. ... Continue with program logic ... 5. End   ","version":"Next","tagName":"h3"},{"title":"Multiple Alternative Selection​","type":1,"pageTitle":"Logic - Selection","url":"/Applied-Problem-Solving/selection#multiple-alternative-selection","content":"   Multiple alternative selection is like an 'E' in the road where a decision must be made and no matter what only one of THREE or more different logic paths will be executed but not all.  Continuing with the preceding example, the application will display an outcome no matter what for only one of these three possibilities:  A new rainfall record was set.The current year rainfall TIED with the highest record.A new record was NOT set.  ","version":"Next","tagName":"h2"},{"title":"Flowchart​","type":1,"pageTitle":"Logic - Selection","url":"/Applied-Problem-Solving/selection#flowchart-2","content":" Here is how it would be done in a flowchart:    ","version":"Next","tagName":"h3"},{"title":"Pseudo Code​","type":1,"pageTitle":"Logic - Selection","url":"/Applied-Problem-Solving/selection#pseudo-code-2","content":" And here is how it would be done in pseudo code.  Function: main()  ---------------------------------------------------------------- Description/Purpose: Demonstration of multiple alternative selection. Argument(s) : NONE Return Value: NONE ---------------------------------------------------------------- main() 1. DECLARE yearlyMM = 325 recordMM = 310 2. DISPLAY: &quot;Current yearly rainfall: &lt;yearlyMM&gt; mm Highest recorded rainfall: &lt;recordMM&gt; mm&quot; 3. What is the state of the current year rainfall? A. NEW RECORD SET (yearlyMM &gt; recordMM): 1. ASSIGN: recordMM = yearlyMM 2. DISPLAY: &quot;A new yearly record has been set!&quot; B. TIED RECORD (yearlyMM == recordMM): 1. DISPLAY: &quot;TIED the highest record!&quot; C. LESS THAN THE RECORD (yearlyMM &lt; recordMM) : 1. DISPLAY: &quot;Did NOT set a new record!&quot; 4. ... Continue with program logic ... 5. End   ","version":"Next","tagName":"h3"},{"title":"Nested Selection​","type":1,"pageTitle":"Logic - Selection","url":"/Applied-Problem-Solving/selection#nested-selection","content":"   Nesting is a way to sequence statements or logic constructs such as selection and iteration within another logical construct. It is a way to group statements or other logic under a dependency. In the case of selection, this would mean anything intended to execute when the selection statement is evaluated to TRUE, would be nested within the limits of the selection.  Using the preceding example on yearly rainfall, let's say we want to have different levels of &quot;excitement&quot; when a new rainfall record is determined. If the old record is beat within 10 mm (inclusive), then we want to state: &quot;A new record has been set!&quot;, but when it is beaten by more than 10 mm, we want it to state: &quot;WOW! The old record was blown away and a new record has been set!&quot;.  Implementing this, would require logic to be placed within the section where it is determined the record was beaten - this would be nested selection!  ","version":"Next","tagName":"h2"},{"title":"Flowchart​","type":1,"pageTitle":"Logic - Selection","url":"/Applied-Problem-Solving/selection#flowchart-3","content":"   The golden highlighted section encompasses the nested selection which is only executed if the parent selection that tests for a beaten record evaluates to TRUE.  ","version":"Next","tagName":"h3"},{"title":"Pseudo Code​","type":1,"pageTitle":"Logic - Selection","url":"/Applied-Problem-Solving/selection#pseudo-code-3","content":" Function: main()  ---------------------------------------------------------------- Description/Purpose: Demonstration of nested selection. Argument(s) : NONE Return Value: NONE ---------------------------------------------------------------- main() 1. DECLARE yearlyMM = 325 recordMM = 310 delta 2. DISPLAY: &quot;Current yearly rainfall: &lt;yearlyMM&gt; mm Highest recorded rainfall: &lt;recordMM&gt; mm&quot; 3. What is the state of the current year rainfall? A. NEW RECORD SET (yearlyMM &gt; recordMM): 1. ASSIGN: delta = yearlyMM - recordMM 2. ASSIGN: recordMM = yearlyMM 3. Is the record beaten by more than 10mm? A. YES (delta &gt; 10): 1. DISPLAY: &quot;WOW! The old record was blown away and a new record has been set!&quot; B. NO: 1. DISPLAY: &quot;A new yearly record has been set!&quot; B. TIED RECORD (yearlyMM == recordMM): 1. DISPLAY: &quot;TIED the highest record!&quot; C. LESS THAN THE RECORD (yearlyMM &lt; recordMM) : 1. DISPLAY: &quot;Did NOT set a new record!&quot; 4. ... Continue with program logic ... 5. End   Step 3. is the outer selection (parent) and sub-step 3.A.3. within the &quot;NEW RECORD SET&quot; section is the nested selection. Nesting is only executed if the parent (outer) dependency is evaluated to TRUE.  ","version":"Next","tagName":"h3"},{"title":"Testing​","type":1,"pageTitle":"Logic - Selection","url":"/Applied-Problem-Solving/selection#testing","content":" As referred to in the computational thinking - testing section, &quot;what-if&quot; scenarios are used to help test the logic and expected outcomes. Selection is pivotal to controlling program execution to take the necessary logic paths required to address all reasonable possibilities and certainly the expected paths to address the problem.  Semantic failures are often directly tied to selection logic, so it is important you build strong selection skills - these skills will also help you be a more efficient and effective problem solver and programmer. ","version":"Next","tagName":"h2"},{"title":"Iteration","type":0,"sectionRef":"#","url":"/Applied-Problem-Solving/iteration","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Iteration","url":"/Applied-Problem-Solving/iteration#overview","content":" It is very common to have to repeat logic, but as we know from the computational thinking model (pattern recognition) approach, placing detailed logic into a function when we know it will be reused or repeated is a good practice, but is it enough?  Let's say we need logic to manage a list of items for a shopping list. We would need repeating logic responsible for getting the user input detail for an item and then add each item to the shopping list (this would be a good use of a function), but how many items will there be? Will a shopping list always have the same number of items? Probably not! We can't limit the logic to sequence a set number of calls to the function that adds a list item because that would be a pretty useless application (what if you want fewer or more?)!  The problem is how to structure the repeating logic so it can be executed any number of times (if at all) and yet refer to the logic only ONCE. This is where the iteration (looping) construct comes in!  To manage a varying possible number of repetitions (iterations/loops), we must apply iteration constructs. There are many forms of these constructs in specific programming languages, but the abstraction (idea/concept) itself is the same with only minor semantic differences. These notes will be focused on the pure concept of iterating (looping) covering two forms:  Optional IterationMandatory Iteration  ","version":"Next","tagName":"h2"},{"title":"Optional Iteration​","type":1,"pageTitle":"Iteration","url":"/Applied-Problem-Solving/iteration#optional-iteration","content":"   Optional iteration is the most common. This involves checking a condition BEFORE the possible repeating logic to determine if looping is even required and if so, iterate until no more iterations are required. This could result in:  No iterationsOne iterationMany iterationsPossible infinite iterations  Technical Insight DISCLAIMER: Something to note about iteration constructs, is that all forms can be made to work like the others however each one has its designed intentions. Optional iteration found in most programming languages include: whileforforeach NOTE: These are language-specific terms and will not be used in the documentation of logic in these notes.  ","version":"Next","tagName":"h2"},{"title":"Flowchart​","type":1,"pageTitle":"Iteration","url":"/Applied-Problem-Solving/iteration#flowchart","content":" Let's continue with the shopping list theme from the introduction. We want to create an application that will allow a user to create as many shopping lists as they want - if any. This will involve iteration since the user can make many lists but we don't know how many. Because this logic approach is optional-based, this means it is possible a shopping list may never be created or many may be created.  NOTE: To help with this example, we will be using a closed-box function to deal with the details of creating a shopping list where items are added to a list. Here's an overview of the function: Name: CreateList ()This function prompts the user to enter as many items as they wish to a shopping list.The function logic details will be described in the pseudo code section example.    ","version":"Next","tagName":"h3"},{"title":"Pseudo Code​","type":1,"pageTitle":"Iteration","url":"/Applied-Problem-Solving/iteration#pseudo-code","content":" NOTE: We will be using a closed-box function that will deal with the details of obtaining item information and adding it to a list of items. Here's an overview of the function: Name and parameter: AddItem (itemList)itemList: Parameter represents the entire shopping list and will implicitly add an item to that list  Function: CreateList()  ---------------------------------------------------------------- Description/Purpose: Demonstration of optional iteration where zero or more shopping items can be added to the list. Argument(s) : NONE Return Value: NONE ---------------------------------------------------------------- CreateList() 1. DECLARE: shoppingList itemCount = 0 2. DISPLAY: &quot;Do you want to add an item to the shopping list? [BUTTON: YES] [BUTTON: NO]&quot; 3. Keep adding items to the shopping list - which button was selected? A. YES: 1. CALL: AddItem (shoppingList) 2. ASSIGN: Add 1 to itemCount 3. Repeat from step #2. 4. Does the shopping list have items? A. YES (itemCount &gt; 0): 1. DISPLAY: &quot;Shopping list ready! There are &lt;itemCount&gt; items.&quot; B. NO (itemCount = 0): 1. DISPLAY: &quot;Shopping list is empty! Don't go shopping!&quot; 5. End   The repeating construct begins in step #3. This iteration may never be executed because it is dependent on the preceding answer to the question of adding an item to the shopping list. If the user selects the NO button the first time, then no items will be added to the list however, as long as the user selects the YES button it will continue iterating adding more items to the shopping list. As soon as the user selects the NO button, the iteration will stop. Step 3.A.3. is critical as it directs the next executed piece of logic back to the add another item prompt where repetition will repeat from.  ","version":"Next","tagName":"h3"},{"title":"Mandatory Iteration​","type":1,"pageTitle":"Iteration","url":"/Applied-Problem-Solving/iteration#mandatory-iteration","content":"   Mandatory iteration is almost the same as optional iteration with the only difference being in the placement of the condition. Unlike optional iteration where the condition is checked first, in mandatory iteration the condition is placed AFTER the logic that would be repeated and will iterate until no more iterations are required. This results in:  At least ONE iterationMany iterationsPossible infinite iterations  Mandatory iteration is usually applied in validation routines where actions must occur at least once before determining if repeating is required. This form involves executing some logic first, then checking a condition AFTER to determine if looping should be repeated until no more iterations are required.  Technical Insight DISCLAIMER: Something to note about iteration constructs, is that all forms can be made to work like the others however each one has its designed intentions. Mandatory iteration found in most programming languages include: do ... while NOTE: This is a language-specific term and will not be used in the documentation of logic in these notes.  ","version":"Next","tagName":"h2"},{"title":"Flowchart​","type":1,"pageTitle":"Iteration","url":"/Applied-Problem-Solving/iteration#flowchart-1","content":" Let's modify the preceding OPTIONAL iteration flowchart example to be MANDATORY iteration. This change will mandate the user to enter at least one shopping list (unlike before where none was possible).    Notice the user is forced to create at least one shopping list because the option of creating a shopping list was moved AFTER the logic that creates a list.  ","version":"Next","tagName":"h3"},{"title":"Pseudo Code​","type":1,"pageTitle":"Iteration","url":"/Applied-Problem-Solving/iteration#pseudo-code-1","content":" Let's modify the preceding OPTIONAL iteration pseudo code example to be MANDATORY iteration. This change will mandate the user to add at least one item to the shopping list (unlike before where none was possible).  Function: CreateList()  ---------------------------------------------------------------- Description/Purpose: Demonstration of mandatory iteration to add at least one shopping item to the list. Argument(s) : NONE Return Value: NONE ---------------------------------------------------------------- CreateList() 1. DECLARE: shoppingList itemCount = 0 2. CALL: AddItem (shoppingList) 3. ASSIGN: Add 1 to itemCount 4. DISPLAY: &quot;Do you want to add another item to the shopping list? [BUTTON: YES] [BUTTON: NO]&quot; 5. Keep adding items to the shopping list - which button was selected? A. YES: 1. Repeat from step #2. 6. DISPLAY: &quot;Shopping list ready! There are &lt;itemCount&gt; items.&quot; 7. End   No matter what, we want the user to add at least one item to the shopping list so we start with the logic that implements that. We don't ask the user for the option to add another item until AFTER one has been added and from there, the user can continue to add as many items as they wish (repeating from step #2).  ","version":"Next","tagName":"h3"},{"title":"Nested Iteration​","type":1,"pageTitle":"Iteration","url":"/Applied-Problem-Solving/iteration#nested-iteration","content":" Nested iterations follow the same concept as a nested selection from the previous topic - it is where an iteration logic construct is placed within another construct.  The below example shows a main iteration for a game (outer/parent loop) and within a game, there is a loop of player moves (this is the nested iteration). The outcome of a &quot;MakeMove&quot; function call determines if the game is over. When the game is over, a new game can be started and the entire process repeats.  ","version":"Next","tagName":"h2"},{"title":"Flowchart​","type":1,"pageTitle":"Iteration","url":"/Applied-Problem-Solving/iteration#flowchart-2","content":"   ","version":"Next","tagName":"h3"},{"title":"Pseudo Code​","type":1,"pageTitle":"Iteration","url":"/Applied-Problem-Solving/iteration#pseudo-code-2","content":" Here is the pseudo code equivalent.  Function: main()  ---------------------------------------------------------------- Description/Purpose: Demonstration of nested iteration. Argument(s) : NONE Return Value: NONE ---------------------------------------------------------------- main() 1. DECLARE newGame = YES gameOver 2. Start a new game? A. YES (newGame=YES): 1. ASSIGN: gameOver=FALSE 2. Game over? A. NO (gameOver=FALSE): 1. ASSIGN: gameOver = CALL MakeMove() 2. Repeat from step 2.A.2. 3. DISPLAY: &quot;Start a new game? [BUTTON:YES] [BUTTON:NO]&quot; 4. ASSIGN: newGame = Selected BUTTON 5. Repeat from step 2. 3. DISPLAY: &quot;Thanks for playing! Bye!&quot; 4. End   Key Parts:  Step 2. is the main game loop (outer/parent)  Step 2.A.2. is the NESTED player moves loop that occurs within a game until it's over ","version":"Next","tagName":"h3"}],"options":{"id":"default"}}